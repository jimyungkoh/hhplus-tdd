# 동시성 제어 방식에 대한 분석 및 보고서 작성

## 비관락과 낙관락

동시성 제어를 위해 비관적 락(Pessimistic Lock)과 낙관적 락(Optimistic Lock) 두 가지 접근 방식이 있습니다:

1. 비관적 락 (Pessimistic Lock):

   - 데이터 접근 시 즉시 락을 획득합니다.
   - 다른 트랜잭션의 접근을 차단하여 동시성 문제를 방지합니다.
   - 충돌이 자주 발생하는 환경에서 유용합니다.
   - 단점: 동시성이 떨어지고 데드락 발생 가능성이 있습니다.

2. 낙관적 락 (Optimistic Lock):
   - 데이터 접근 시 락을 획득하지 않고, 수정 시점에 충돌을 확인합니다.
   - 버전 정보나 타임스탬프를 이용해 충돌을 감지합니다.
   - 충돌이 적은 환경에서 높은 동시성을 제공합니다.
   - 단점: 충돌 발생 시 롤백과 재시도가 필요합니다.

본 프로젝트에서는 비관적 락 방식을 채택했습니다. 포인트 시스템의 특성상 데이터 정확성이 중요하고, 충돌이 빈번할 수 있어 비관적 락이 더 적합하다고 판단했습니다.

## 락의 종류와 고려사항

동시성 제어를 위해 다양한 종류의 락이 사용됩니다:

1. 뮤텍스(Mutex): 상호 배제를 위한 기본적인 락 메커니즘으로, 한 번에 하나의 스레드만 접근을 허용합니다.
2. 세마포어(Semaphore): 여러 스레드의 동시 접근을 제어하며, 리소스 풀 관리에 유용합니다.
3. 스핀락(Spinlock): CPU를 계속 점유하며 대기하는 방식으로, 짧은 대기 시간에 효율적입니다.
4. 리더-라이터 락(Reader-Writer Lock): 읽기 작업과 쓰기 작업을 구분하여 동시성을 향상시킵니다.

### 자원을 점유중인 스레드가 락을 반환하지 않는 경우

Node.js의 싱글 스레드 이벤트 루프 모델에서는 전통적인 의미의 '스레드'가 존재하지 않지만, 비동기 작업이 완료되지 않거나 콜백 함수가 실행되지 않는 상황이 발생할 수 있습니다. 이는 다음과 같은 문제를 야기할 수 있습니다:

1. 이벤트 루프 블로킹: 긴 시간 동안 실행되는 동기 작업이 이벤트 루프를 차단하여 다른 작업의 실행을 방해할 수 있습니다.

2. 메모리 누수: 비동기 작업이 완료되지 않아 관련 리소스가 해제되지 않을 수 있습니다.

3. 데드락 유사 상황: 비동기 작업 간의 순환 의존성으로 인해 서로 완료되지 못하는 상황이 발생할 수 있습니다.

4. 타임아웃 처리 부재: 비동기 작업에 타임아웃 메커니즘이 없으면 무한정 대기할 수 있습니다.

5. 프로미스 체인 중단: 프로미스 체인에서 오류가 제대로 처리되지 않으면 후속 작업이 실행되지 않을 수 있습니다.

이러한 문제들은 Node.js 애플리케이션의 안정성과 성능에 심각한 영향을 미칠 수 있으며, 특히 동시성이 요구되는 상황에서 더욱 두드러집니다.

### 스핀락 선택과 Map을 이용한 락 관리

본 프로젝트에서는 동시성 제어를 위해 스핀락 기반의 TimeoutSpinLock을 구현하여 사용했습니다. 이 선택은 다음과 같은 이유로 이루어졌습니다:

1. 짧은 대기 시간 처리: 포인트 시스템의 특성상 빠른 락 획득과 해제가 필요한 상황이 많아 스핀락이 효과적입니다.
2. 이벤트 루프 친화적: Node.js의 비동기 특성과 잘 어울리며, 이벤트 루프 기반 환경에서 효율적으로 동작합니다.
3. 세밀한 제어: 사용자별로 독립적인 락을 관리할 수 있어 세밀한 동시성 제어가 가능합니다.

다만, 스핀락의 CPU 자원 소모 문제를 해결하기 위해 타임아웃 메커니즘을 추가했습니다. 이를 통해 무한 대기 상태를 방지하고 시스템 안정성을 높였습니다.

TimeoutSpinLock 클래스는 다음과 같이 구현되었습니다:

export class TimeoutSpinLock {
  // 락의 상태를 나타내는 boolean 값
  private locked = false;

  // 락을 획득하는 비동기 메서드
  // 지정된 시간 내에 락을 획득하지 못하면 에러를 발생시킴
  async acquire(timeoutMs: number = 50_000): Promise<void> {
    const startTime = Date.now();
    while (!this.tryLock()) {
      if (Date.now() - startTime > timeoutMs) {
        throw new Error('Lock acquisition timed out');
      }
      await new Promise((resolve) => setTimeout(resolve, 10));
    }
  }

  // 락 획득을 시도하는 내부 메서드
  // 락이 해제 상태면 락을 획득하고 true를 반환, 아니면 false를 반환
  private tryLock(): boolean {
    if (!this.locked) {
      this.locked = true;
      return true;
    }
    return false;
  }

  // 락을 해제하는 메서드
  release(): void {
    this.locked = false;
  }
}

이 구현은 비동기 환경에서 효율적으로 동작하며, 타임아웃 처리를 통해 시스템 안정성을 보장합니다.

락 관리를 위해 Map을 사용한 LockManager 클래스도 구현했습니다:

export class LockManager {
  // 싱글톤 인스턴스를 저장하는 정적 변수
  private static instance: LockManager;
  // 사용자 ID를 키로, TimeoutSpinLock 객체를 값으로 가지는 Map
  readonly locks: Map<number, TimeoutSpinLock>;

  // 프라이빗 생성자: 외부에서 직접 인스턴스 생성을 방지
  private constructor() {
    this.locks = new Map();
  }

  // 싱글톤 인스턴스를 반환하는 정적 메서드
  static getInstance(): LockManager {
    if (!LockManager.instance) {
      LockManager.instance = new LockManager();
    }
    return LockManager.instance;
  }

  // 주어진 ID에 대한 락 객체를 반환하는 메서드
  // 해당 ID의 락이 없으면 새로 생성하여 반환
  getLock(id: number): TimeoutSpinLock {
    if (!this.locks.has(id)) {
      this.locks.set(id, new TimeoutSpinLock());
    }
    return this.locks.get(id);
  }
}

LockManager는 싱글톤 패턴을 사용하여 전역적으로 일관된 락 관리를 보장하며, Map을 통해 각 사용자별로 독립적인 락을 관리합니다.

이렇게 LockManager를 통해 사용자별로 Lock을 관리함으로써, 서로 다른 사용자의 요청이 동시에 들어오더라도 각 사용자의 락이 서로 영향을 주지 않습니다.

## 이벤트 루프로 보는 타임아웃 스핀락

Node.js의 이벤트 루프 특성을 고려한 타임아웃 스핀락의 동작은 다음과 같습니다:

1. 비동기 락 획득: acquire 메서드는 async/await를 사용하여 비동기적으로 동작합니다.
2. 논블로킹 대기: while 루프 내에서 setTimeout을 사용하여 이벤트 루프의 다른 작업 실행을 방해하지 않습니다.
3. 타임아웃 처리: Date.now()를 사용하여 경과 시간을 체크하고, 초과 시 에러를 발생시킵니다.

이 구현은 Node.js의 비동기 특성을 활용하여 효율적인 동시성 제어를 가능하게 합니다.

![Event Loop and Timeout Spinlock](https://i.imgur.com/vAyBEPY.png)

## 시나리오 테스트

1. 대량의 동시 포인트 충전 시나리오

   ```typescript
   test('100개의 요청이 동시에 포인트를 충전할 때 순서를 보장하며 정확한 결과를 반환해야 한다', async () => {
     const userId = 13;
     const chargeAmount = 10;
     const concurrentRequests = 100;
     // ... (테스트 코드)
   }, 40_000);
   ```

   설명: 이 테스트는 한 명의 사용자가 100개의 동시 충전 요청을 보내는 시나리오를 시뮬레이션합니다. 각 요청은 10포인트를 충전하며, 최종적으로 사용자의 포인트가 정확히 1000포인트(10 \* 100)가 되는지 확인합니다. 이는 시스템의 동시성 처리 능력과 정확성을 검증합니다.

2. 여러 사용자의 동시 포인트 충전 및 사용 시나리오

   ```typescript
   test('여러 사용자가 동시에 포인트를 충전하고 사용할 때 각 사용자의 요청이 독립적으로 처리되어야 한다', async () => {
     const user1Id = 9;
     const user2Id = 10;
     // ... (테스트 코드)
   }, 10_000);
   ```

   설명: 이 테스트는 두 명의 사용자가 동시에 다른 작업을 수행하는 시나리오를 테스트합니다. 한 사용자는 3번의 충전을, 다른 사용자는 3번의 사용을 동시에 수행합니다. 각 사용자의 최종 포인트가 예상대로 정확히 계산되는지 확인합니다.

3. 처리 시간이 다른 사용자 요청의 독립성 시나리오

   ````typescript
   test('한 사용자의 요청 처리 시간이 길어져도 다른 사용자의 요청 처리에 영향을 주지 않아야 한다', async () => {
     const user1Id = 11; // 처리 시간이 긴 사용자
     const user2Id = 12; // 일반 사용자
     // ... (테스트 코드)
   }, 10_000);
   ```
   설명: 이 테스트는 한 사용자의 요청 처리가 지연될 때 다른 사용자의 요청이 영향을 받지 않는지 확인합니다. 한 사용자의 요청에 1초의 지연을 추가하고, 다른 사용자의 요청이 2초 미만에 처리되는지 검증합니다.

   ````

4. 복합 시나리오 테스트
   ```typescript
   test('여러 사용자의 포인트 충전 및 사용 시나리오가 올바르게 처리되어야 한다', async () => {
     const users = [1, 2, 3];
     // ... (테스트 코드)
   });
   ```
   설명: 이 테스트는 세 명의 사용자가 다양한 포인트 충전 및 사용 작업을 수행하는 복합 시나리오를 시뮬레이션합니다. 충전, 사용, 한도 초과 시도 등 다양한 상황을 포함하며, 각 작업 후 사용자의 최종 포인트와 거래 내역이 정확한지 확인합니다.
